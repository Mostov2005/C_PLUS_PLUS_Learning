#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <memory>
#include <windows.h>
using namespace std;

class Task1 {
public:
    void run() {
        // SetConsoleOutputCP(CP_UTF8);

        cout <<
                "1. Создайте неинициализированные указатели разных типов и инициализированные nullptr"
                " и посмотрит на них и по ним (попробуйте разыменовать).\n";
        int *p1; // неинициализированный
        double *p2 = nullptr; // инициализированный
        char *p3;
        cout << "Адрес p1 (мусор): " << p1 << endl;
        // cout << "Разыменовать адрес p1: " << *p1 << endl;
        cout << "Адрес p2 (nullptr): " << p2 << endl;
        // cout << "Адрес p3 (char): " << p3 << endl;

        char str[] = "Hello";
        p3 = str;
        cout << "p3 -> " << p3 << "\n"; // Указывает на первый символ, но пишет до конца '\0'
        cout << "p3 -> " << *p3 << "\n";

        cout << "\n2. Выделите память с подходящими значениями, посмотрите ещё раз.\n";
        // Выделяем память под одно число
        int *p = new int(123);
        cout << "Адрес p: " << p << ", значение: " << *p << endl;

        // массив
        int *arr = new int[3]{10, 20, 30};
        cout << "Адрес первого элемента массива: " << arr << endl;
        cout << "arr[0] = " << *arr << endl;
        cout << "arr[1] = " << *(arr + 1) << endl;
        cout << "arr[2] = " << arr[2] << endl;

        // Для строк
        char *s = new char[6]{'H', 'e', 'l', 'l', 'o', '\0'};
        cout << "Адрес строки s: " << static_cast<void *>(s) << endl;
        cout << "s (строка) -> " << s << endl; // Указывает на первый символ, но пишет до конца '\0'
        cout << "*s (первый символ) -> " << *s << endl;

        delete[] s;

        cout << "\n3. Арифметика указателей \n";
        int *arr2 = new int[3]{10, 20, 30};
        cout << "arr[0] = " << *arr2 << ", arr[1] = " << *(arr2 + 1) << ", arr[2] = " << *(arr2 + 2) << endl;
        cout << "Попытка выйти за пределы: " << *(arr2 + 3) << endl;


        // дальше разбираться
        cout << "\n4. Изменение по байтам\n";
        int num = 0x12345678;
        unsigned char *b = reinterpret_cast<unsigned char *>(&num);
        cout << "Было: " << hex << num << " Байты: "; // hex - переключает вывод чисел в шестнадцатеричный формат
        for (int i = 0; i < 4; i++) cout << (int) b[i] << " ";
        b[1] = 0xAA;
        cout << "\nСтало: " << num << endl;

        cout << dec; // переключает обратно в десятичный формат

        cout << "\n=== 5. Потеря указателя ===\n";
        int *lost = new int(777);
        int *temp = lost; // сохраняем адрес
        delete lost; // освободили память
        // lost теперь висячий указатель (dangling)
        cout << "Адрес (висячий): " << temp << ", значение: " << *temp << endl;
        cout << "Само значение: " << lost << ", значение: " << *lost << endl;


        cout << "\n=== 6. Освобождение памяти и перезапись ===\n";
        delete p;
        delete[] arr;
        // После delete, p и arr указывают в никуда — использовать нельзя

        p = new int(555);       // перезаписываем p
        arr = new int[3]{1,2,3}; // перезаписываем arr

        cout << "p = " << *p << ", arr[0] = " << arr[0] << endl;

        delete p;
        delete[] arr;

        cout << "\n=== 7. Свои эксперименты ===\n";

        // 7a. unique_ptr вместо обычных указателей
        unique_ptr<int[]> uptr = make_unique<int[]>(5);
        for (int i = 0; i < 5; i++) uptr[i] = i * 10;

        cout << "Элементы через unique_ptr: ";
        for (int i = 0; i < 5; i++) cout << uptr[i] << " ";
        cout << endl;

        // 7b. Арифметика указателей через get()
        int* raw = uptr.get(); // сырой указатель
        cout << "Через сырой указатель: ";
        for (int i = 0; i < 5; i++) cout << *(raw + i) << " ";
        cout << endl;

        // 7c. Перезапись памяти через новый указатель
        int* a = new int(100);
        cout << "Адрес a = " << a << ", значение = " << *a << endl;
        delete a;                  // память освобождена
        a = new int(200);          // возможно тот же адрес
        cout << "Новый указатель a = " << a << ", значение = " << *a << endl;
        delete a;

        // 7d. Память для массива и выход за границы
        int* arrExp = new int[3]{1,2,3};
        cout << "arrExp[3] (выход за пределы, UB!) = " << *(arrExp + 3) << endl;
        delete[] arrExp;
    }
};


// Проведите эксперименты с указателями, выделением и освобождением памяти:
// 1. Создайте неинициализированные указатели разных типов и инициализированные nullptr и "посмотрите" на них и по ним (попробуйте разыменовать).
// 2. Выделите память с подходящими значениями, посмотрите ещё раз.
// 3. Используя арифметику указателей, попробуйте "заглянуть" внутрь значений и за их пределы.
// 4. Измените значение, используя доступ к отдельным байтам.
// 5. "Потеряйте" прямой указатель на область памяти и посмотрите на содержимое с помощью арифметики указателей.
// 6. Освободите память и посмотрите на её содержимое. Попробуйте добиться, чтобы память по этому адресу была перезаписана.
// 7.* Придумайте свои эксперименты.
